extends ../_layout

block vars
  - title = title || 'User Interfaces for Live Programming';
  - description = description || 'Live programming eliminates the gulf between code and execution. To design live programming systems, we first need to understand what we are developing. Once we gain domain-specific knowledge of the target applications, we create user interfaces to edit the running application, such as scrubbing sliders, color palettes, and timeline interfaces. The key to the fluid programming experience of live programming is the combination of deep understanding of the target applications and adoption of interactive user interfaces.';
  - imageUrl = `${protocol}://${domain}${rootPath}images/panels/live-programming.jpg`;
  - me = 'live-programming/';
  - const slideUrl = `${protocol}://${domain}${rootPath}publications/live2017-kato-keynote-slides.pdf`;
  - const slideImagePath = `${rootPath}live-programming/live2017/live2017-kato-keynote-slides`;

block post-footer
  a.ui.circular.icon.popup-menu.large.grey.hidden.button
    i.sidebar.icon
  .ui.hidden.popup-menu.popup: .ui.divided.list
    a.item(href='#body')
      i.chevron.circle.up.icon
      .content #{en ? 'Top' : 'トップ'}
    a.item(href='#abstract')
      i.right.triangle.icon
      .content #{en ? 'Abstract' : '概要'}
    - if (en) {
    a.item(href='#presentations')
      i.right.triangle.icon
      .content Presentation materials
    - } else {
    a.item(href='#presentation-jssst2023')
      i.right.triangle.icon
      .content 日本ソフトウェア科学会 第40回大会 チュートリアル
    a.item(href='#presentation-live2017')
      i.right.triangle.icon
      .content LIVE 2017 基調講演
    - }
    a.item(href='#further-readings')
      i.right.triangle.icon
      .content #{en ? 'Relevant projects' : '関連プロジェクト'}
    a.item(href='#revisions')
      i.right.triangle.icon
      .content #{en ? 'Revision history' : '更新履歴'}

block main
  section
    h1.ui.header #{title}
    +render-share()
    .ui.horizontal.divided.list.project-meta-list
      .item
        span.ui.red.tiny.basic.label
          | #{en ? 'Keynote Talk at LIVE \'17' : "LIVE \'17 基調講演"}
      .item
        span.ui.red.tiny.basic.label
          | #{en ? 'Tutorial course at JSSST \'23' : "日本ソフトウェア科学会大会 第40回大会 チュートリアル"}
    - if (en) {
    .ui.message
      p The page provides summary for 
        a(href='https://2017.splashcon.org/event/live-2017-keynote-a') the keynote talk at LIVE '17 workshop
        |  and links to relevant sub-projects including 
        a(href=`${basePath}live-tuning/`) Live Tuning
        |  and 
        a(href=`${basePath}user-generated-variables/`) User-Generated Variables
        | .
    - }
    .ui.hidden.divider
  section#abstract: +abstract()
  .ui.hidden.divider
  block presentations
    section#presentations
      +presentation-live2017()
  .ui.hidden.divider
  section#further-readings: +further-readings()
  .ui.hidden.divider
  section#revisions: +revisions()

mixin abstract()
  h2.ui.header #{en ? 'Summary' : '概要'}
  .ui.basic.segment
    p #{description}
    block introduction
      p In the keynote talk at LIVE '17, I discussed the liveness of programming systems in light of user interface design. I introduced user interfaces for programming and discussed the importance of integrating graphical representations into programming environments. I extended the scope of &quot;liveness&quot; by describing two kinds of interactions, physical and developer-user, and provided insights on designing future live programming systems.
      p In particular, regarding the user interfaces for enhancing developer-user interactions, there are two sub-projects called 
        a(href=`${basePath}live-tuning/`) Live Tuning
        |  and 
        a(href=`${basePath}user-generated-variables/`) User-Generated Variables
        | .

mixin presentation-live2017()
  h2.ui.header #{en ? 'Presentation materials' : 'LIVE 2017 基調講演'}
  .ui.basic.segment
    .ui.stackable.two.columns.grid
      .column
        h3.ui.header #{en ? 'LIVE 2017 Keynote Slides' : '発表スライド'}
        .ui.embed(data-url=slideUrl, data-placeholder=`${slideImagePath}00.jpg`, data-icon='video play outline')
        .caption: .ui.horizontal.list
          .item
            a(href=slideUrl)
              i.download.icon
              | #{en ? 'Download' : 'ダウンロード'}
      .column
        h3.ui.header #{en ? 'What is Live Programming?' : 'ライブプログラミングとは？'}
        a.ui.fluid.bordered.image(href=`${slideImagePath}05.jpg`)
          img(src=`${slideImagePath}05.jpg`)
        .caption
          - if (en) {
          p Live Programming refers to a <abbr title="Programming Experience">PX</abbr> that provides continuous feedback to the programmer about the program being developed.
          - } else {
          p ライブプログラミングとは、開発中のプログラムについてプログラマに継続的なフィードバックを提供する<abbr title="Programming Experience（プログラミング体験）">PX</abbr>を指します。
          - }
  .ui.basic.segment
    - if (en) {
    p Live Programming systems provide concrete information about how the program behaves when it is executed. With help of this concrete information, programmers can easily iterate on editing and testing the program behavior.
    p Please note that the origin of Live Programming is not new as you can see early examples in visual programming and object-oriented programming environments. Then, why is it attracting much attention these days? In short, I consider it is because of its focus on the user experience.
    - } else {
    p ライブプログラミングのシステムは、プログラムが実行されたときどう振る舞うかについて、具体的な情報を提供します。この具体的な情報の助けを借りて、プログラマはプログラムの編集やデバッグを簡単に繰り返すことができます。
    p ライブプログラミングの起源は、ビジュアルプログラミングやオブジェクト指向プログラミングのための環境の初期の事例まで辿ることができ、決して新しいものではありません。では、なぜ最近、改めて注目を集めているのでしょうか？一言で言えば、ユーザ体験への注力があるからだと私は考えています。
    - }
  .ui.basic.segment
    .ui.stackable.two.columns.grid
      .column
        a.ui.fluid.bordered.image(href=`${slideImagePath}13.jpg`)
          img(src=`${slideImagePath}13.jpg`)
      .column
        .caption
          - if (en) {
          p Live Programming requires decent user interfaces for exploring the problem space.
          p As such, building decent Live Programming systems requires deep understanding on the target application domains; e.g. avoid sudden changes in the program behavior, keep the program and its output relevant, and allow continuously exploring the problem space.
          - } else {
          p ライブプログラミングを実現するには、問題空間を探索するための適切なユーザインタフェースが必要です。
          p そのため、適切なライブプログラミングのシステムを構築するには、対象となるアプリケーションのドメインについて深く理解する必要があります。例えば、プログラムの動作がとつぜん大きく変化しないようにしたり、プログラムと出力の間の関連付けが失われないようにしたり、問題空間を継続的に探索できるようにしたりといったことが重要です。
          - }
  .ui.basic.segment
    - if (en) {
    p From now on, I will discuss three perspectives on user interface design of Live Programming systems.
    - } else {
    p ここからは、ライブプログラミングのためのユーザインタフェース設計について考えるための三つの観点を紹介していきます。
    - }
    .ui.stackable.three.columns.grid
      .column
        h4.ui.header #{en ? 'Programming with End-users' : 'エンドユーザとプログラミングする'}
        a.ui.fluid.bordered.image(href=`${slideImagePath}18.jpg`)
          img(src=`${slideImagePath}18.jpg`)
        .caption
          - if (en) {
          p As Live Programming systems provide interactive and intuitive user interfaces for debugging and editing programs, some of the user interfaces can be exposed to the end-users so that they can customize the programs as they wish. [
            a(href=`${basePath}live-tuning/`) Live Tuning
            | ]
          p When the provided user interfaces cannot satisfy their needs, they can still submit requests to programmers with rich contextual information provided by the Live Programming systems. [
            a(href=`${basePath}user-generated-variables/`) User-Generated Variables
            | ]
          p Live Programming techniques benefit not only programmers, but also end-users, and enable 
            a(href=`${basePath}programming-as-communication/`) Programming as Communication
            | .
          - } else {
          p ライブプログラミングのシステムは、プログラムのデバッグや編集のためのインタラクティブで直感的なユーザインタフェースを提供します。こうしたインタフェースの一部をエンドユーザに解放すれば、プログラムの振る舞いを容易にカスタマイズできるようになります。 [
            a(href=`${basePath}live-tuning/`) Live Tuning
            | ]
          p また、エンドユーザがプログラムの既存のユーザインタフェースで満足できない場合にも、ライブプログラミングのシステムが提供する豊富なコンテクスト情報を用いて、プログラマに機能リクエストを送ることが容易になります。 [
            a(href=`${basePath}user-generated-variables/`) User-Generated Variables
            | ]
          p ライブプログラミングの技術はプログラマだけでなくエンドユーザにも恩恵のあるもので、「
            a(href=`${basePath}programming-as-communication`) コミュニケーションとしてのプログラミング
            | 」という新しい考え方をもたらします。
          - }
      .column
        h4.ui.header #{en ? 'Programming this Material World' : '実世界をプログラミングする'}
        a.ui.fluid.bordered.image(href=`${slideImagePath}27.jpg`)
          img(src=`${slideImagePath}27.jpg`)
        .caption
          - if (en) {
          p Live Programming often targets simple applications such as drawing graphics. In contrast, &quot;software is eating the world&quot; and there are complex and interesting applications such as physical computing and virtual reality.
          p Their actual &quot;framerate&quot; can be very slow; e.g. printing device enclosures and producing scent. Emulating, or sometimes even pretending, is needed to provide the continuous feedback.
          p Making full use of five senses in programming environments would be crucial in the near future.
          - } else {
          p ライブプログラミングのシステムの事例には、グラフィックを描画する単純なアプリケーションを対象とするものが多く見られます。しかし、それとは対照的に、「Software is eating the world」とも言われる現在、フィジカルコンピューティングやバーチャルリアリティなどの複雑で興味深いアプリケーションが多数現れています。
          p そうしたアプリケーションにおける「フレームレート」は、例えばデバイス筐体の印刷や香りの生成などの場合、非常に遅いです。継続的なフィードバックを提供するためには、情報をエミュレートすること、（ないものがあたかもそこにあるかのような）フリをすることが必要になります。
          p プログラミング環境において五感をフルに活用することは、近い将来、非常に重要になってくるはずです。
          - }
      .column
        h4.ui.header #{en ? 'Programming with Time Travel' : '時間旅行しながらプログラミングする'}
        a.ui.fluid.bordered.image(href=`${slideImagePath}39.jpg`)
          img(src=`${slideImagePath}39.jpg`)
        .caption
          - if (en) {
          p Live Programming puts focus on providing live feedback to the programmer, but it does not always mean providing realtime information of the running program.
          p The timeline interface and record and replay features together provide time traveling experience and play an important role to find critical timings in the history. Once the timing of interest is found, editing the code and program input would update the program output, allowing the programmer to explore future&quot;s.&quot;
          - } else {
          p ライブプログラミングは、プログラマに「ライブ」なフィードバックを提供することを重視しますが、それは必ずしも、実行中のプログラムに関する情報をリアルタイムに提供することを意味しません。
          p プログラムの振る舞いを記録・再生する機能を備えたタイムラインインタフェースは、時間旅行のような体験を通して、プログラムの実行履歴の中から興味深いタイミングを見つけるために重要な役割を果たします。特定のタイミングを見つけたら、コードまたはプログラム入力、あるいはその両方を編集することで、プログラムの出力を更新し、ありえたかもしれない未来を自由に探索することができます。
          - }
  .ui.basic.segment
    a.ui.fluid.bordered.image(href=`${slideImagePath}47.jpg`)
      img(src=`${slideImagePath}47.jpg`)
    .caption
      - if (en) {
      p Designing Live Programming systems is not just about language design, a single user, a single UI, it is about designing the whole experience.
      p Live Programming is a very interdisciplinary topic and involves all of Programming Language design, Software Engineering, and designing Human-Computer Interaction. LIVE, PX workshops and 
        a(href='https://sigpx.org/en') SIGPX
        |  are such an attempt to attract people from all of these research fields.
      - } else {
      p ライブプログラミングのシステム設計は、プログラミング言語の設計、一人のユーザのための設計、単一のユーザインタフェースの設計に留まらず、全体としての体験設計に他なりません。
      p ライブプログラミングは非常に学際的なトピックであり、プログラミング言語、ソフトウェア工学、Human-Computer Interactionのすべてにまたがる研究分野です。こうした多分野の人々を惹きつける試みとして、LIVE、PX、
        a(href='https://sigpx.org') SIGPX
        | といった集まりがあります。
      - }

mixin further-readings()
  h2.ui.header
    i.lab.icon
    .content #{en ? 'Relevant projects' : '関連プロジェクト'}
  .ui.basic.segment
    - if (en) {
    p The following projects implement or discuss Live Programming experiences.
    - } else {
    p ライブプログラミング体験を実装したり議論したりしているプロジェクトが表示されています。
    - }
  .ui.segment
    .ui.divided.items.projects
      - for (const p of projects) {
      //- skip concept, committee, and private projects
      - if (p.category === 'concept' || p.category === 'committee' || p.category === 'private') continue;
      //- 
      - if (!Array.isArray(p.tags) || p.tags.indexOf('live-programming') < 0) continue;
      +render-project-item(p)
      - }

mixin revisions()
  h2.ui.header
    i.announcement.icon
    | #{en ? 'Revision history' : '更新履歴'}
  .ui.basic.segment: .ui.divided.feed
    block news
      - if (!en) {
      .event: .content
        .date 9/27/2023
        .summary LIVE 2017基調講演の内容を和訳
      - }
      .event: .content
        .date 9/25/2023
        .summary
          - if (en) {
          | Add introduction to the tutorial course held as part of 
          a(href='https://jssst2023.wordpress.com/tutorial') The 40th 
            abbr(title='Japan Society for Software Science and Technology') JSSST
            |  Annual Conference
          |  (only available in 
          a(href=`${rootPath}ja/live-programming`) the Japanese page
          | ).
          - } else {
          | 日本ソフトウェア科学会 第40回大会 チュートリアルのコンテンツ追加を開始
          - }
      .event: .content
        .date 2/15/2018
        .summary #{en ? 'Replace &quot;Further reading&quot; with the list of relevant projects. Please visit each project page for further readings.' : '関連プロジェクトの一覧を公開'}
      .event: .content
        .date 1/21/2018
        .summary #{en ? 'Upload the initial prototype version.' : '初版を公開'}
